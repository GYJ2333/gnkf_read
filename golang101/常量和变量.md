# 常量和变量

  

  

  

  ### 类型不确定值（untyped value）和类型确定值（typed value）

  在Go中，有些值的类型是不确定的，这些值的类型有很多可能性。 这些值称为类型不确定值。对于大多数类型不确定值来说，它们各自都有一个默认类型， 除了预声明的`nil`。`nil`是没有默认类型的。

   事实上，Go中大多数的类型不确定值都属于字面常量和本文即将介绍的有名常量。 少数类型不确定值包括刚提到的`nil`和以后会逐步解触到的某些操作的布尔返回值。

  

  字面常量（无名常量）都属于类型不确定值，一个字面（常）量的默认类型取决于它为何种字面量形式：

  如下u-z都是类型不确定值：

  ```go
  package main
  import "fmt"
  func main() {
    //Untyped
    var u = 123      //Default hidden type is int
    var v = "circle" //Default hidden type is string
    var w = 5.6      //Default hidden type is float64
    var x = true     //Default hidden type is bool
    var y = 'a'      //Default hidden type is rune
    var z = 3 + 5i   //Default hidden type is complex128
    fmt.Printf("Type: %T Value: %v\n", u, u)
    fmt.Printf("Type: %T Value: %v\n", v, v)
    fmt.Printf("Type: %T Value: %v\n", w, w)
    fmt.Printf("Type: %T Value: %v\n", x, x)
    fmt.Printf("Type: %T Value: %v\n", y, y)
    fmt.Printf("Type: %T Value: %v\n", z, z)
  }
  ```
  类型确定和类型不确定的区别
  ```go
  const a int32 = 8     //Typed Const
  const a = 8           //Untyped Const,默认类型是int
  8                     //类型不确定常量，默认类型是int
  'a'                   //默认类型是rune(int32)
  ```

  

  

  

  ### 类型不确定常量的显式类型转换

  和很多语言一样，Go也支持类型转换。 一个显式类型转换的形式为`T(v)`，其表示将一个值`v`转换为类型`T`。 编译器将`T(v)`的转换结果视为一个类型为`T`的类型确定值。 当然，对于一个特定的类型`T`，`T(v)`并非对任意的值`v`都合法。

  对于一个类型不确定常量值`v`，有两种情形显式转换`T(v)`是合法的：

  1. `v`[可以表示为](https://gfw.go101.org/article/basic-types-and-value-literals.html#representability)`T`类型的一个值。 转换结果为一个类型为`T`的类型确定常量值。
  2. `v`的默认类型是一个整数类型（`int`或者`rune`） 并且`T`是一个字符串类型。 转换`T(v)`将`v`看作是一个Unicode码点。 转换结果为一个类型为`T`的字符串常量。 此字符串常量只包含一个Unicode码点，并且可以看作是此Unicode码点的UTF-8表示形式。 对于不在合法的Unicode码点取值范围内的整数`v`， 转换结果等同于字符串字面量`"\uFFFD"`（亦即`"\xef\xbf\xbd"`）。 `0xFFFD`是Unicode标准中的（非法码点的）替换字符值。 （但是请注意，今后的Go版本可能[只允许rune或者byte整数被转换为字符串](https://github.com/golang/go/issues/3939)。 从Go官方工具链1.15版本开始，`go vet`命令会对从非rune和非byte整数到字符串的转换做出警告。）

  事实上，第二种情形并不要求`v`必须是一个常量。 如果`v`是一个常量，则转换结果也是一个常量。 如果`v`不是一个常量，则转换结果也不是一个常量。

  一些合法的转换例子：

  ```go
  // 结果为complex128类型的1.0+0.0i。虚部被舍入了。
  complex128(1 + -1e-1000i)
  // 结果为float32类型的0.5。这里也舍入了。
  float32(0.49999999)
  // 只要目标类型不是整数类型，舍入都是允许的。
  float32(17000000000000000)
  float32(123)
  uint(1.0)
  int8(-123)
  int16(6+0i)
  complex128(789)
  
  string(65)          // "A"
  string('A')         // "A"
  string('\u68ee')    // "森"
  string(-1)          // "\uFFFD"
  string(0xFFFD)      // "\uFFFD"
  string(0x2FFFFFFFF) // "\uFFFD"
  ```

  

  下面是一些非法的转换：

  ```go
  int(1.23)     // 1.23不能被表示为int类型值。
  uint8(-1)     // -1不能被表示为uint8类型值。
  float64(1+2i) // 1+2i不能被表示为float64类型值。
  
  // -1e+1000不能被表示为float64类型值。不允许溢出。
  float64(-1e1000)
  // 0x10000000000000000做为int值将溢出。
  int(0x10000000000000000)
  
  // 字面量65.0的默认类型是float64（不是一个整数类型）。
  string(65.0)
  // 66+0i的默认类型是complex128（不是一个整数类型）。
  string(66+0i)
  ```

  从上面的例子可以看出，一个类型不确定数字值所表示的值可能溢出它的默认类型的表示范围。 比如上例中的`-1e1000`和`0x10000000000000000`。 一个溢出了它的默认类型的表示范围的类型不确定数字值是不能被转换到它的默认类型的（将编译报错）。

  注意，有时一个显式转换形式必须被写成`(T)(v)`以免发生歧义。 这种情况多发生在`T`不为一个标识符的时候。

  ```go
  *Point(p)        // 同 *(Point(p))
  (*Point)(p)      // p 被转换为 *Point
  <-chan int(c)    // 同 <-(chan int(c))
  (<-chan int)(c)  // c 被转换为 <-chan int
  func()(x)        // 函数签名 func() x
  (func())(x)      // x 被转换为 func()
  (func() int)(x)  // x 被转换为 func() int
  func() int(x)    // x 被转换为 func() int (明确的)
  ```

  我们以后将在其它章节学到更多的显式类型转换规则。

  

  ### 类型推断介绍

  Go支持类型推断（type deduction or type inference）。 类型推断是指在某些场合下，程序员可以在代码中使用一些类型不确定值， 编译器会自动推断出这些类型不确定值在特定情景下应被视为某些特定类型的值。

  在Go代码中，如果某处需要一个特定类型的值并且一个类型不确定值可以表示为此特定类型的值， 则此类型不确定值可以使用在此处。Go编译器将此类型不确定值视为此特定类型的类型确定值。 这种情形常常出现在运算符运算、函数调用和赋值语句中。
  ```go
  a:=1                         //赋值
  a=b+1                        //运算
  func a(b int) int {return 3} //函数返回
  A:=a(32)                     //函数调用
  ```

  有些场景对某些类型不确定值并没有特定的类型要求。在这种情况下，Go编译器将这些类型不确定值视为它们各自的默认类型的类型确定值。

  上述两条类型推断规则可以被视为隐式转换规则。

  本文下面的章节将展示一些类型推断的例子。 后续其它文章将会展示更多类型推断的例子和规则。

  

  ### （有名）常量声明（constant declaration）

  和无名字面常量一样，有名常量也必须都是布尔、数字或者字符串值。 在Go中，关键字`const`用来声明有名常量。 下面是一些常量声明的例子。

  ```go
  package main
  
  // 声明了两个单独的有名常量。（是的，
  // 非ASCII字符可以用做标识符。）
  const π = 3.1416
  const Pi = π // 等价于：const Pi = 3.1416
  
  // 声明了一组有名常量。
  const (
  	No         = !Yes
  	Yes        = true
  	MaxDegrees = 360
  	Unit       = "弧度"
  )
  
  func main() {
  	// 声明了三个局部有名常量。
  	const DoublePi, HalfPi, Unit2 = π * 2, π * 0.5, "度"
  }
  ```

  

  Go白皮书把上面每行含有一个等号`=`的语句称为一个常量描述（constant specification）。 每个`const`关键字对应一个常量声明。一个常量声明中可以有若干个常量描述。 上面的例子中含有4个常量声明。除了第3个，其它的常量声明中都各自只有一个常量描述。 第3个常量声明中有4个常量描述。

  

  常量声明中的等号`=`表示“绑定”而非“赋值”。 每个常量描述将一个或多个字面量绑定到各自对应的有名常量上。 或者说，每个有名常量其实代表着一个字面常量。

  在上面的例子中，有名常量`π`和`Pi`都绑定到（或者说代表着）字面常量`3.1416`。 这两个有名常量可以在程序代码中被多次使用，从而有效避免了字面常量使用过多，在需要修改字面常量时需要大面积寻找字面常量的位置。当然常量声明也可常常增加代码的可读性（**代码即注释**）。

  以后，我们使用非常量这一术语表示不是常量的值。 下一节将要介绍的变量就属于非常量。

  注意，常量可以直接声明在包中，也可以声明在函数体中。 声明在函数体中的常量称为局部常量（local constant），直接声明在包中的常量称为包级常量（package-level constant）。 包级常量也常常被称为全局常量。

  包级常量声明中的常量描述的顺序并不重要。比如在上面的例子中， 常量描述`No`和`Yes`的顺序可以掉换一下。

  

  #### 类型确定有名常量

  我们可以在声明一些常量的时候指定这些常量的确切类型。 这样声明的常量称为类型确定有名常量。 在下面这个例子中，所有这4个声明的常量都是类型确定的。 `X`和`Y`的类型都是`float32`， `A`和`B`的类型都是`int64`。

  ```go
  const X float32 = 3.14
  
  const (
  	A, B int64   = -3, 5
  	Y    float32 = 2.718
  )
  ```

  如果一个常量描述中包含多个类型确定常量，则这些常量的类型必然是一样的， 比如上例中的`A`和`B`。

  我们也可以使用显式类型转换来声明类型确定常量。 下面的例子和上面的例子是完全等价的。

  ```go
  const X = float32(3.14)
  
  const (
  	A, B = int64(-3), int64(5)
  	Y    = float32(2.718)
  )
  ```

  

  欲将一个字面常量绑定到一个类型确定有名常量上，此字面常量必须能够表示为此常量的确定类型的值。 否则，编译将报错。

  ```go
  const a uint8 = 256             // error: 256溢出uint8
  const b = uint8(255) + uint8(1) // error: 256溢出uint8
  const c = int8(-128) / int8(-1) // error: 128溢出int8
  const MaxUint_a = uint(^0)      // error: -1溢出uint
  const MaxUint_b uint = ^0       // error: -1溢出uint
  ```

  在上面的例子中，符号`^`为位反运算符，符号`+`为加法运算符，符号`/`为除法运算符。

  下面这个类型确定常量声明在64位的操作系统上是合法的，但在32位的操作系统上是非法的。 因为一个`uint`值在32位操作系统上的尺寸是32位， `(1 << 64) - 1`将溢出`uint`。（这里，符号`<<`为左移位运算符。）

  ```go
  const MaxUint uint = (1 << 64) - 1
  ```

  

  那么如何声明一个代表着最大`uint`值的常量呢？ 我们可以用下面这个常量声明来替换上面这个。下面这个声明在在64位和32位的操作系统上都是合法的。

  ```go
  const MaxUint = ^uint(0)
  ```

  

  类似地，我们可以使用下面这个常量声明来声明一个有名常量来表示最大的`int`值。（这里，符号`>>`为右移位运算符。）

  ```go
  const MaxInt = int(^uint(0) >> 1)
  ```

  

  使用类似的方法，我们可以声明一个常量来表示当前操作系统的位数，或者检查当前操作系统是32位的还是64位的。

  ```go
  const NativeWordBits = 32 << (^uint(0) >> 63) // 64 or 32
  const Is64bitOS = ^uint(0) >> 63 != 0
  const Is32bitOS = ^uint(0) >> 32 == 0
  ```


  这里，符号`!=`和`==`分别为不等于和等于比较运算符。

  #### 常量声明中的自动补全

  在一个包含多个常量描述的常量声明中，除了第一个常量描述，其它后续的常量描述都可以只有标识符部分。 Go编译器将通过照抄前面最紧挨的一个完整的常量描述来自动补全不完整的常量描述。 比如，在编译阶段，编译器会将下面的代码

  ```go
  const (
  	X float32 = 3.14
  	Y                // 这里必须只有一个标识符
  	Z                // 这里必须只有一个标识符
  
  	A, B = "Go", "language"
  	C, _
  	// 上一行中的空标识符是必需的（如果
  	// 上一行是一个不完整的常量描述）。
  )
  ```

  自动补全为

  ```go
  const (
  	X float32 = 3.14
  	Y float32 = 3.14
  	Z float32 = 3.14
  
  	A, B = "Go", "language"
  	C, _ = "Go", "language"
  )
  ```

  

  #### 在常量声明中使用`iota`

  `iota`是Go中预声明（内置）的一个特殊的有名常量。 `iota`被预声明为`0`，但是它的值在编译阶段并非恒定。 当此预声明的`iota`出现在一个常量声明中的时候，它的值在第n个常量描述中的值为`n`（从0开始）。 所以`iota`只对含有多个常量描述的常量声明有意义。

  `iota`和常量描述自动补全相结合有的时候能够给Go编程带来很大便利。 比如，下面是一个使用了这两个特性的例子。 请阅读代码注释以了解清楚各个常量被绑定的值。

  ```go
  package main
  
  func main() {
  	const (
  		k = 3 // 在此处，iota == 0
  
  		m float32 = iota + .5 // m float32 = 1 + .5
  		n                     // n float32 = 2 + .5
  
  		p = 9             // 在此处，iota == 3
  		q = iota * 2      // q = 4 * 2
  		_                 // _ = 5 * 2
  		r                 // r = 6 * 2
  		s, t = iota, iota // s, t = 7, 7
  		u, v              // u, v = 8, 8
  		_, w              // _, w = 9, 9
  	)
  
  	const x = iota // x = 0 （iota == 0）
  	const (
  		y = iota // y = 0 （iota == 0）
  		z        // z = 1
  	)
  
  	println(m)             // +1.500000e+000
  	println(n)             // +2.500000e+000
  	println(q, r)          // 8 12
  	println(s, t, u, v, w) // 7 7 8 8 9
  	println(x, y, z)       // 0 0 1
  }
  ```

  

  上面的例子只是展示了一下如何使用`iota`。 在实际编程中，我们应该用有意义的方式使用之。比如：

  ```go
  const (
  	Failed = iota - 1 // == -1
  	Unknown           // == 0
  	Succeeded         // == 1
  )
  
  const (
  	Readable = 1 << iota // == 1
  	Writable             // == 2
  	Executable           // == 4
  )
  ```

  在上面这段代码中，`-`是一个减法运算符。

  

  ### 变量声明和赋值操作语句

  变量可以被看作是在运行时刻存储在内存中并且可以被更改的有名字的值。

  所有的变量值都是类型确定值。当声明一个变量的时候，我们必须在代码中给编译器提供足够的信息来让编译器推断出此变量的确切类型。

  在一个函数体内声明的变量称为局部变量。 **在任何函数体外声明的变量称为包级或者全局变量**。

  Go语言有两种变量声明形式。一种称为标准形式，另一种称为短声明形式。 短声明形式只能用来声明局部变量。

  #### 标准变量声明形式

  每条标准变量声明形式语句起始于一个`var`关键字。 每个`var`关键字跟随着一个变量名。 每个变量名必须为一个[标识符](https://gfw.go101.org/article/keywords-and-identifiers.html#identifier)。

  下面是几条完整形式的标准变量声明语句。 这些声明确地指定了被声明的变量的类型和初始值。

  ```go
  var lang, website string = "Go", "https://golang.org"
  var compiled, dynamic bool = true, false
  var announceYear int = 2009
  ```

  我们可以看到，和常量声明一样，多个同类型的变量可以在一条语句中被声明。

  完整形式的标准变量声明使用起来有些罗嗦，因此很少在日常Go编程中使用。 在日常Go编程中，另外两种变种形式用得更广泛一些。 一种变种形式省略了变量类型（但仍指定了变量的初始值），这时编译器将根据初始值的字面量形式来推断出变量的类型。 另一种变种形式省略了初始值（但仍指定了变量类型），这时编译器将使用变量类型的零值做为变量的初始值。

  下面是一些第一种变种形式的用例。在这些用例中，如果一个初始值是一个类型确定值，则对应声明的变量的类型将被推断为此初始值的类型； 如果一个初始值是一个类型不确定值，则对应声明的变量的类型将被推断为此初始值的默认类型。 注意在这种变种中，同时声明的多个变量的类型可以不一样。

  ```go
  // 变量lang和dynamic的类型将被推断为内置类型string和bool。
  var lang, dynamic = "Go", false
  
  // 变量compiled和announceYear的类型将被推断
  // 为内置类型bool和int。
  var compiled, announceYear = true, 2009
  
  // 变量website的类型将被推断为内置类型string。
  var website = "https://golang.org"
  ```

  上例中的类型推断可以被视为隐式类型转换。

  下例展示了几个省略了初始值的标准变量声明。每个声明的变量的初始值为它们各自的类型的零值。

  ```go
  var lang, website string      // 两者都被初始化为空字符串。
  var interpreted, dynamic bool // 两者都被初始化为false。
  var n int                     // 被初始化为0。
  ```

  

  和常量声明一样，多个变量可以用一对小括号组团在一起被声明。

  ```go
  var (
  	lang, bornYear, compiled     = "Go", 2007, true
  	announceAt, releaseAt    int = 2009, 2012
  	createdBy, website       string
  )
  ```

  上面这个变量声明语句已经被`go fmt`命令格式化过了。 这个变量声明语句包含三个变量描述（variable specification）。

  一般来说，将多个相关的变量声明在一起将增强代码的可读性。

  

  #### 纯赋值语句

  在上面展示的变量声明的例子中，等号`=`表示赋值。 一旦一个变量被声明之后，它的值可以被通过纯赋值语句来修改。 多个变量可以同时在一条赋值语句中被修改。

  一个赋值语句等号左边的表达式必须是一个可寻址的值、一个映射元素或者一个空标识符。 内存地址（以及指针）和映射将在以后的文章中介绍。

  常量是不可改变的（不可寻址的），所以常量不能做为目标值出现在纯赋值语句的左边，而只能出现在右边用做源值。 变量既可以出现在纯赋值语句的左边用做目标值，也可以出现在右边用做源值。

  空标识符也可以出现在纯赋值语句的左边，表示不关心对应的目标值。 空标识符不可被用做源值。

  一个包含了很多（合法或者不合法的）纯赋值语句的例子：

  ```go
  const N = 123
  var x int
  var y, z float32
  
  N = 789 // error: N是一个不可变量
  y = N   // ok: N被隐式转换为类型float32
  x = y   // error: 类型不匹配
  x = N   // ok: N被隐式转换为类型int
  y = x   // error: 类型不匹配
  z = y   // ok
  _ = y   // ok
  
  z, y = y, z               // ok
  _, y = y, z               // ok
  z, _ = y, z               // ok
  _, _ = y, z               // ok
  x, y = 69, 1.23           // ok
  x, y = y, x               // error: 类型不匹配
  x, y = int(y), float32(x) // ok
  ```

  上例中的最后一行使用了显式类型转换，否则此赋值（见倒数第二行）将不合法。 数字非常量值的类型转换规则将在后边的章节介绍。

  Go不支持某些其它语言中的连等语法。下面的赋值语句在Go中是不合法的。

  ```go
  var a, b int
  a = b = 123 // 语法错误
  ```

  

  #### 短变量声明形式

  我们也可以用短变量声明形式来声明一些局部变量。比如下例：

  ```go
  package main
  
  func main() {
  	// 变量lang和year都为新声明的变量。
  	lang, year := "Go language", 2007
  
  	// 这里，只有变量createdBy是新声明的变量。
  	// 变量year已经在上面声明过了，所以这里仅仅
  	// 改变了它的值，或者说它被重新声明了。
  	year, createdBy := 2009, "Google Research"
  
  	// 这是一个纯赋值语句。
  	lang, year = "Go", 2012
  
  	print(lang, "由", createdBy, "发明")
  	print("并发布于", year, "年。")
  	println()
  }
  ```

  **每个短声明语句中必须至少有一个新声明的变量**。

  从上面的例子中，我们可以看到短变量声明形式和标准变量声明形式有几个显著的区别：

  1. 短声明形式不包含`var`关键字，并且不能指定变量的类型。
  2. 短变量声明中的赋值符号必须为`:=`。
  3. 在一个短声明语句的左侧，已经声明过的变量和新声明的变量可以共存。 但在一个标准声明语句中，所有出现在左侧的变量必须都为新声明的变量。

  注意，相对于纯赋值语句，目前短声明语句有一个限制：出现在一个短声明左侧的项必须都为纯标识符。 以后我们将学习到在纯赋值语句的左边可以出现结构体值的字段，指针的解引用和容器类型值的元素索引项等。 但是这些项不能出现在一个变量短声明语句的左边。

  #### 关于“赋值”这个术语

  以后，当“赋值”这个术语被提到的时候，它可以指一个纯赋值、一个短变量声明或者一个初始值未省略的标准变量声明。 事实上，一个更通用的定义包括后续文章将要介绍的[函数传参](https://gfw.go101.org/article/function-declarations-and-calls.html#call)。

  当`y = x`是一条合法的赋值语句时，我们可以说***`x`可以被赋给`y`\***。 假设`y`的类型为`Ty`，有时为了叙述方便，我们也可以说***`x`可以被赋给类型`Ty`\***。

  一般来说，如果`x`可以被赋给`y`，则`y`应该是可修改的，并且`x`和`y`的类型相同或者`x`可以被隐式转换到`y`的类型。 当然，`y`也可以是空标识符`_`。

  #### 每个局部声明的变量至少要被有效使用一次

  注意，当使用目前的主流Go编译器编译Go代码时，一个局部变量被声明之后至少要被有效使用一次，否则编译器将报错。 包级变量无此限制。 如果一个变量总是被当作赋值语句中的目标值，那么我们认为这个变量没有被有效使用过。

  下面这个例子编译不通过。

  ```go
  package main
  
  var x, y, z = 123, true, "foo" // 包级变量
  
  func main() {
  	var q, r = 789, false
  	r, s := true, "bar"
  	r = y // r没有被有效使用。
  	x = q // q被有效使用了。
  }
  ```

  当编译上面这个程序的时候，编译器将报错（这个程序代码存在一个名为`example-unused.go`的文件中）：

  ```
  ./example-unused.go:6:6: r declared and not used
  ./example-unused.go:7:16: s declared and not used
  ```

  

  避免编译器报错的方法很简单，要么删除相关的变量声明，要么像下面这样，将未曾有效使用过的变量（这里是`r`和`s`）赋给空标识符。

  ```go
  package main
  
  var x, y, z = 123, true, "foo"
  
  func main() {
  	var q, r = 789, false
  	r, s := true, "bar"
  	r = y
  	x = q
  
  	_, _ = r, s // 将r和s做为源值使用一次。
  }
  ```

  #### 若干包级变量在声明时刻的依赖关系将影响它们的初始化顺序

  下面这个例子中的声明的变量的初始化顺序为`y = 5`、`c = y`、`b = c+1`、`a = b+1`、`x = a+1`。

  ```go
  var x, y = a+1, 5         // 8 5
  var a, b, c = b+1, c+1, y // 7 6 5
  ```

  

  包级变量在初始化的时候不能相互依赖。比如，下面这个变量声明语句编译不通过。

  ```go
  var x, y = y, x
  ```

  ### 值的可寻址性

  在Go中，有些值是可以被寻址的。上面已经提到所有变量都是可以寻址的，所有常量都是不可被寻址。 我们可以从后面的[指针](https://gfw.go101.org/article/pointer.html)一文了解更多关于内存地址和指针的知识。

  ### 非常量数字值相关的显式类型转换规则

  在Go中，两个类型不一样的[基本类型](https://gfw.go101.org/article/basic-types-and-value-literals.html)值是不能相互赋值的。 我们必须使用显式类型转换将一个值转换为另一个值的类型之后才能进行赋值。

  前面某节已经提到了整数（不论常量还是非常量）都可以被显式转换为字符串类型。 这里再介绍两个不同类型数字值之间的转换规则。

  - 一个非常量浮点数和整数可以显式转换到其它任何一个浮点数和整数类型。
  - 一个非常量复数可以显式转换到其它任何一个复数类型。

  上面已经提到，常量数字值的类型转换不能溢出。此规则不适用于非常量数字值的类型转换。 **非常量数字值的类型转换中，溢出是允许的**。 另外当将一个浮点数非常量值（比如一个变量）转换为一个整数类型的时候，舍入（或者精度丢失）也是允许的。 具体规则如下：

  - 当从一个比特位数多的整数类型的非常量整数值向一个比特位数少的整数类型转换的时候，高位的比特将被舍弃，低位的比特将被保留。我们称这种处理方式为截断（truncated）或者回绕（wrapped around）。
  - 当从一个非常量的浮点数向一个整数类型转换的时候，浮点数的小数部分将被舍弃（向零靠拢）。
  - 当从一个非常量整数或者浮点数向一个浮点数类型转换的时候，精度丢失是可以发生的。
  - 当从一个非常量复数向另一个复数类型转换的时候，精度丢失也是可以发生的。
  - 当一个显式转换涉及到非常量浮点数或者复数数字值时，如果源值溢出了目标类型的表示范围，则转换结果取决于具体编译器实现（即行为未定义）。

  在下面的例子中，第*7*行和第*15*行的隐式转换是不允许的，第*5*行和第*14*行的显式转换也是不允许的。

  ```go
  const a = -1.23
  // 变量b的类型被推断为内置类型float64。
  var b = a
  // error: 常量1.23不能被截断舍入到一个整数。
  var x = int32(a)
  // error: float64类型值不能被隐式转换到int32。
  var y int32 = b
  // ok: z == -1，变量z的类型被推断为int32。
  //     z的小数部分将被舍弃。
  var z = int32(b)
  
  const k int16 = 255
  var n = k            // 变量n的类型将被推断为int16。
  var f = uint8(k + 1) // error: 常量256溢出了uint8。
  var g uint8 = n + 1  // error: int16值不能隐式转换为uint8。
  var h = uint8(n + 1) // ok: h == 0，变量h的类型为uint8。
                       // (n+1)溢出uint8，所以只有低8位
                       // bits（都为0）被保留。
  ```

  第*3*行的隐式转换中，`a`被转换为它的默认类型（`float64`）；因此`b`的类型被推断为`float64`。

  ### 变量和常量的作用域

  在Go中，我们可以使用一对大括号来显式形成一个（局部）代码块。一个代码块可以内嵌另一个代码块。 最外层的代码块称为包级代码块。 一个声明在一个内层代码块中的常量或者变量将遮挡另一个外层代码块中声明的同名变量或者常量。 比如，下面的代码中声明了3个名为`x`的变量。 内层的`x`将遮挡外层的`x`， 从而外层的`x`在内层的`x`声明之后在内层中将不可见。

  ```go
  package main
  
  const y = 70
  var x int = 123 // 包级变量
  
  func main() {
  	// 此x变量遮挡了包级变量x。
  	var x = true
  
  	// 一个内嵌代码块。
  	{
  		x, y := x, y-10 // 这里，左边的x和y均为新声明
  		                // 的变量。右边的x为外层声明的
  		                // bool变量。右边的y为包级变量。
  
  		// 在此内层代码块中，从此开始，
  		// 刚声明的x和y将遮挡外层声明x和y。
  
  		x, z := !x, y/10 // z是一个新声明的变量。
  		                 // x和y是上一句中声明的变量。
  		println(x, y, z) // false 60 6
  	}
  	println(x) // true
  	println(y) // 70 （包级变量y从未修改）
  	/*
  	println(z) // error: z未定义。
  	           // z的作用域仅限于上面的最内层代码块。
  	*/
  }
  ```

  

  刚提到的作用域是指一个标识符的可见范围。 一个包级变量或者常量的作用域为其所处于的整个代码包。 一个局部变量或者常量的作用域开始于此变量或者常量的声明的下一行，结束于最内层包含此变量或者常量的声明语句的代码块的结尾。 这解释了为什么上例中的`println(z)`将编译不通过。

  后面的[代码块和作用域](https://gfw.go101.org/article/blocks-and-scopes.html)一文将详述代码块和标识符的作用域。

  ### 更多关于常量声明

  #### 一个类型不确定常量所表示的值可以溢出其默认类型

  比如，下例中的三个类型不确定常量均溢出了它们各自的默认类型，但是此程序编译和运行都没问题。

  ```go
  package main
  
  // 三个类型不确定常量。
  const n = 1 << 64          // 默认类型为int
  const r = 'a' + 0x7FFFFFFF // 默认类型为rune
  const x = 2e+308           // 默认类型为float64
  
  func main() {
  	_ = n >> 2
  	_ = r - 0x7FFFFFFF
  	_ = x / 2
  }
  ```

  

  但是下面这个程序编译不通过，因为三个声明的常量为类型确定常量。

  ```go
  package main
  
  // 三个类型确定常量。
  const n int = 1 << 64           // error: 溢出int
  const r rune = 'a' + 0x7FFFFFFF // error: 溢出rune
  const x float64 = 2e+308        // error: 溢出float64
  
  func main() {}
  ```

  

  #### 每个常量标识符将在编译的时候被其绑定的字面量所替代

  常量声明可以看作是增强型的C语言中的`#define`宏。 在编译阶段，所有的标识符将被它们各自绑定的字面量所替代。

  如果一个运算中的所有运算数都为常量，则此运算的结果也为常量。或者说，此运算将在编译阶段就被估值。 下一篇文章将介绍Go中的[常用运算符](https://gfw.go101.org/article/operators.html)。

  一个例子：

  ```go
  package main
  
  const X = 3
  const Y = X + X
  var a = X
  
  func main() {
  	b := Y
  	println(a, b, X, Y)
  }
  ```

  上面这段程序代码将在编译阶段被重写为下面这样：

  ```go
  package main
  
  var a = 3
  
  func main() {
  	b := 6
  	println(a, b, 3, 6)
  }
  ```





# 运算操作符

本文将介绍适用于基本类型值的各种运算操作符。

### 常量表达式

在继续下面的章节之前，我们需要知道什么叫常量表达式和关于常量表达式估值的一个常识。 表达式的概念将在[表达式和语句](https://gfw.go101.org/article/expressions-and-statements.html)一文中得到解释。 目前我们只需知道本文中所提及的大多数运算都属于表达式。 当一个表达式中涉及到的所有操作数都是常量时，此表达式称为一个常量表达式。 一个常量表达式的估值是在编译阶段进行的。一个常量表达式的估值结果依然是一个常量。 如果一个表达式中涉及到的操作数中至少有一个不为常量，则此表达式称为非常量表达式。

### 算术运算符

Go支持五个基本二元算术运算符：

| 字面形式 | 名称 |                  对两个运算数的要求                  |
| :------: | :--: | :--------------------------------------------------: |
|    +     | 加法 |     两个运算数的类型必须相同并且为基本数值类型。     |
|    -     | 减法 |                                                      |
|    *     | 乘法 |                                                      |
|    /     | 除法 |                                                      |
|    %     | 余数 | 两个运算数的类型必须相同并且为基本**整数**数值类型。 |

Go支持六种位运算符（也属于算术运算）：

| 字面形式 |    名称    |                对两个操作数的要求以及机制解释                |
| :------: | :--------: | :----------------------------------------------------------: |
|    &     |    位与    | 两个操作数的类型必须相同并且为基本整数数值类型。机制解释（下标`2`表明一个字面量为二进制）：`11002 & 10102` 得到 `10002``11002 | 10102` 得到 `11102``11002 ^ 10102` 得到 `01102``11002 &^ 10102` 得到 `01002` |
|    \|    |    位或    |                                                              |
|    ^     | （位）异或 |                                                              |
|    &^    |    清位    |                                                              |
|    <<    |   左移位   | 左操作数必须为一个整数，右操作数也必须为一个整数（如果它是一个常数，则它必须非负），但它们的类型可以不同。 （注意：在Go 1.13之前，右操作数必须为一个无符号整数类型的类型确定值或者一个可以表示成`uint`值的[类型不确定](https://gfw.go101.org/article/constants-and-variables.html#untyped-value)常数值。）一个负右操作数（非常数）将在运行时刻造成一个恐慌。机制解释：`11002 << 3` 得到 `11000002`（低位补零）`11002 >> 3` 得到 `12`（低位被舍弃）注意，在右移运算中，左边空出来的位（即高位）全部用左操作数的最高位（即正负号位）填充。 比如如果左操作数`-128`的类型为`int8`（二进制补码表示为`100000002`）， 则`100000002 >> 2`的二进制补码结果为`111000002`（即`-32`）。 |
|    >>    |   右移位   |                                                              |

Go也支持三个一元算术运算符：

| 字面形式 |      名称      |                             解释                             |
| :------: | :------------: | :----------------------------------------------------------: |
|    +     |     取正数     |                      `+n`等价于`0 + n`.                      |
|    -     |     取负数     |                      `-n`等价于`0 - n`.                      |
|    ^     | 位反（或位补） | `^n`等价于`m ^ n`，其中`m`和`n`同类型并且它的二进制表示中所有比特位均为1。 比如如果`n`的类型为`int8`，则`m`的值为`-1`；如果`n`的类型为`uint8`，则`m`的值为`255`。 |

注意：

- 在很多其它流行语言中，位反运算符是用`~`表示的。
- 和一些其它流行语言一样，加号运算符`+`也可用做字符串衔接运算符（见下）。
- 和C及C++语言一样，`*`除了可以当作乘号运算符，它也可以用做指针解引用运算符； `&`除了可以当作位与运算符，它也可以用做取地址运算符。 后面的[指针](https://gfw.go101.org/article/pointer.html)一文将详解内存地址和指针类型。
- 和Java不一样，Go支持无符号数，所以Go不需要无符号右移运算符`>>>`。
- Go不支持幂运算符， 我们必须使用`math`标准库包中的`Pow`函数来进行幂运算。 下一篇文章将详解[包和包引入](https://gfw.go101.org/article/packages-and-imports.html)。
- 清位运算符`&^`是Go中特有的一个运算符。 `m &^ n`等价于`m & (^n)`。



一些运算符的使用示例：

```go
func main() {
	var (
		a, b float32 = 12.0, 3.14
		c, d int16   = 15, -6
		e	uint8   = 7
	)

	// 这些行编译没问题。
	_ = 12 + 'A' // 两个类型不确定操作数（都为数值类型）
	_ = 12 - a   // 12将被当做a的类型（float32）使用。
	_ = a * b    // 两个同类型的类型确定操作数。
	_ = c % d
	_, _ = c + int16(e), uint8(c) + e
	_, _, _, _ = a / b, c / d, -100 / -9, 1.23 / 1.2
	_, _, _, _ = c | d, c & d, c ^ d, c &^ d
	_, _, _, _ = d << e, 123 >> e, e >> 3, 0xF << 0
	_, _, _, _ = -b, +c, ^e, ^-1

	// 这些行编译将失败。
	_ = a % b   // error: a和b都不是整数
	_ = a | b   // error: a和b都不是整数
	_ = c + e   // error: c和e的类型不匹配
	_ = b >> 5  // error: b不是一个整数
	_ = c >> -5 // error: -5不是一个无符号整数

	_ = e << uint(c) // 编译没问题
	_ = e << c       // 从Go 1.13开始，此行才能编译过
	_ = e << -c      // 从Go 1.13开始，此行才能编译过。
	                 // 将在运行时刻造成恐慌。
	_ = e << -1      // error: 右操作数不能为负（常数）
}
```



#### 关于溢出

上一篇文章提到了

- 一个类型确定数字型常量所表示的值是不能溢出它的类型的表示范围的。
- 一个类型不确定数字型常量所表示的值是可以溢出它的默认类型的表示范围的。 当一个类型不确定数字常量值溢出它的默认类型的表示范围时，此数值不会被截断（亦即回绕）。
- 将一个非常量数字值转换为其它数字类型时，此非常量数字值可以溢出转化结果的类型。 在此转换中，当溢出发生时，转化结果为此非常量数字值的截断（亦即回绕）表示。

对于一个算数运算的结果，上述规则同样适用。

示例：

```go
// 结果为非常量
var a, b uint8 = 255, 1
var c = a + b  // c==0。a+b是一个非常量表达式，
               // 结果中溢出的高位比特将被截断舍弃。
var d = a << b // d == 254。同样，结果中溢出的
               // 高位比特将被截断舍弃。

// 结果为类型不确定常量，允许溢出其默认类型。
const X = 0x1FFFFFFFF * 0x1FFFFFFFF // 没问题，尽管X溢出
const R = 'a' + 0x7FFFFFFF          // 没问题，尽管R溢出

// 运算结果或者转换结果为类型确定常量
var e = X                // error: X溢出int。
var h = R                // error: R溢出rune。
const Y = 128 - int8(1)  // error: 128溢出int8。
const Z = uint8(255) + 1 // error: 256溢出uint8。
```



#### 关于算术运算的结果

除了移位运算，对于一个二元算术运算，

- 如果它的两个操作数都为类型确定值，则此运算的结果也是一个和这两个操作数类型相同的类型确定值。
- 如果只有一个操作数是类型确定的，则此运算的结果也是一个和此类型确定操作数类型相同的类型确定值。 另一个类型不确定操作数的类型将被推断为（或隐式转换为）此类型确定操作数的类型。
- 如果它的两个操作数均为类型不确定值，则此运算的结果也是一个类型不确定值。 在运算中，两个操作数的类型将被设想为它们的默认类型中一个（按照此优先级来选择：`complex128`高于`float64`高于`rune`高于`int`）。 结果的默认类型同样为此设想类型。 比如，如果一个类型不确定操作数的默认类型为`int`，另一个类型不确定操作数的默认类型为`rune`， 则前者的类型在运算中也被视为`rune`，运算结果为一个默认类型为`rune`的类型不确定值。

对于移位运算，结果规则有点小复杂。首先移位运算的结果肯定都是整数。

- 如果左操作数是一个类型确定值（则它的类型必定为整数），则此移位运算的结果也是一个和左操作数类型相同的类型确定值。
- 如果左操作数是一个类型不确定值**并且右操作数是一个常量**，则左操作数将总是被视为一个整数。 如果它的默认类型不是一个整数（`rune`或`int`），则它的默认类型将被视为`int`。 此移位运算的结果也是一个类型不确定值并且它的默认类型和左操作数的默认类型一致。
- 如果左操作数是一个类型不确定值**并且右操作数是一个非常量**，则左操作数将被首先转化为运算结果的期待设想类型。 如果期待设想类型并没有被指定，则左操作数的默认类型将被视为它的期待设想类型。 如果此期待设想类型不是一个基本整数类型，则编译报错。 当然最终运算结果是一个类型为此期待设想类型的类型确定值。

一些非移位算术运算的例子：

```go
func main() {
	// 三个类型不确定常量。它们的默认类型
	// 分别为：int、rune和complex64.
	const X, Y, Z = 2, 'A', 3i


	var a, b int = X, Y // 两个类型确定值

	// 变量d的类型被推断为Y的默认类型：rune（亦即int32）。
	d := X + Y
	// 变量e的类型被推断为a的类型：int。
	e := Y - a
	// 变量f的类型和a及b的类型一样：int。
	f := a * b
	// 变量g的类型被推断为Z的默认类型：complex64。
	g := Z * Y

	// 2 65 (+0.000000e+000+3.000000e+000i)
	println(X, Y, Z)
	// 67 63 130 (+0.000000e+000+1.950000e+002i)
	println(d, e, f, g)
}
```



一个移位算术运算的例子：

```go
const N = 2
// A == 12，它是一个默认类型为int的类型不确定值。
const A = 3.0 << N
// B == 12，它是一个类型为int8的类型确定值。
const B = int8(3.0) << N

var m = uint(32)
// 下面的三行是相互等价的。
var x int64 = 1 << m  // 1的类型将被设想为int64，而非int
var y = int64(1 << m) // 同上
var z = int64(1) << m // 同上

// 下面这行编译不通过。
/*
var _ = 1.23 << m // error: 浮点数不能被移位
*/
```





上面提到的移位运算结果的最后一点类型推断规则有点反常。 这条规则的主要目的是为了防止一些移位运算在32位架构和64位架构的机器上的运算结果出现不一致但不一致却没有被及时发现的情况。 比如如果上面一段代码中第*10*行（或第*9*行）的`1`的类型被推断为它的默认类型`int`， 则在32位架构的机器上，`x`的取值在运行时刻将被截断为*0*，而在64位架构的机器上，`x`的取值在运行时刻将为*232*。 因为`m`是一个变量，在32位架构的机器上，第*9*行和第*10*行并不会在编译时刻报错。 这将导致Go程序员在不经意间写出没有料到的和难以觉察的bug。 因此，第*9*行和第*10*行中的`1`的类型被推断为`int64`（最终的设想结果类型），而不是它们的默认类型`int`。

下面这段代码展示了对于左操作数为类型不确定值的移位运算，编译结果因右操作数是否为常量而带来的不同结果：

```go
const n = uint(2)
var m = uint(2)

// 这两行编译没问题。
var _ float64 = 1 << n
var _ = float64(1 << n)

// 这两行编译失败。
var _ float64 = 1 << m  // error
var _ = float64(1 << m) // error
```

上面这段代码最后两行编译失败是因为它们都等价于下面这两行：

```go
var _ = float64(1) << m
var _ = 1.0 << m // error: shift of type float64
```



另一个例子：

```go
package main

const n = uint(8)
var m = uint(8)

func main() {
	println(a, b) // 2 0
}

var a byte = 1 << n / 128
var b byte = 1 << m / 128
```

上面这个程序打印出`2 0`，因为最后两行等价于：

```go
var a = byte(int(1) << n / 128)
var b = byte(1) << m / 128
```



#### 关于除法和余数运算

假设两个操作数`x`和`y`的类型为同一个整数类型， 则它们通过除法和余数运算得到的商`q`（`= x / y`）和余数`r`（`= x % y`）满足`x == q*y + r`（`|r| < |y|`）。如果余数`r`不为零，则它的符号和被除数`x`相同。商`q`的结果为`x / y`向零靠拢截断。

如果除数`y`是一个常量，则它必须不为0，否则编译不通过。 如果它是一个整数型非常量，则在运行时刻将抛出一个恐慌（panic）。 恐慌类似与某些其它语言中的异常（exception）。 我们将在以后的文章中了解到Go中的恐慌和恐慌恢复机制。 如果除数`y`非整数型的非常量，则运算结果为一个无穷大（Inf，当被除数不为0时）或者NaN（not a number，当被除数为0时）。

示例：

```go
println( 5/3,   5%3)  // 1 2println( 5/-3,  5%-3) // -1 2println(-5/3,  -5%3)  // -1 -2println(-5/-3, -5%-3) // 1 -2println(5.0 / 3.0)     // 1.666667println((1-1i)/(1+1i)) // -1ivar a, b = 1.0, 0.0println(a/b, b/b) // +Inf NaN_ = int(a)/int(b) // 编译没问题，但在运行时刻将造成恐慌。// 这两行编译不通过。println(1.0/0.0) // error: 除数为0println(0.0/0.0) // error: 除数为0
```



#### `op=`运算符

对于一个二元算数运算符`op`，语句`x = x op y`可以被简写为`x op= y`。 在这个简写的语句中，`x`只会被估值一次。

示例：

```go
var a, b int8 = 3, 5a += bprintln(a) // 8a *= aprintln(a) // 64a /= bprintln(a) // 12a %= bprintln(a) // 2b <<= uint(a)println(b) // 20
```

#### 自增和自减操作符

和很多其它流行语言一样，Go也支持自增（`++`）和自减（`--`）操作符。 不过和其它语言不一样的是，自增（`aNumber++`）和自减（`aNumber--`）操作操作没有返回值， 所以它们不能当做[表达式](https://gfw.go101.org/article/expressions-and-statements.html)来使用。 另一个显著区别是，在Go中，自增（`++`）和自减（`--`）操作符只能后置，不能前置。

一个例子：

```go
package mainfunc main() {	a, b, c := 12, 1.2, 1+2i	a++ // ok. <=> a += 1 <=> a = a + 1	b-- // ok. <=> b -= 1 <=> b = b - 1	c++ // ok.	// 下面这些行编译不通过。	/*	_ = a++	_ = b--	_ = c++	++a	--b	++c	*/}
```

### 字符串衔接运算符

上面已经提到了，加法运算符也可用做字符串衔接运算符。

| 字面形式 |    名称    |          对两个操作数的要求          |
| :------: | :--------: | :----------------------------------: |
|    +     | 字符串衔接 | 两个操作数必须为同一类型的字符串值。 |

`+=`运算符也适用于字符串衔接。

示例：

```go
println("Go" + "lang") // Golangvar a = "Go"a += "lang"println(a) // Golang
```



如果一个字符串衔接运算中的一个操作值为类型确定的，则结果字符串是一个类型和此操作数类型相同的类型确定值。 否则，结果字符串是一个类型不确定值（肯定是一个常量）。

### 布尔（又称逻辑）运算符

Go支持两种布尔二元运算符和一种布尔一元运算符。

| 字面形式 |      名称      |               对操作值的要求               |
| :------: | :------------: | :----------------------------------------: |
|    &&    | 布尔与（二元） |    两个操作值的类型必须为同一布尔类型。    |
|   \|\|   | 布尔或（二元） |                                            |
|    !     | 布尔否（一元） | 唯一的一个操作值的类型必须为一个布尔类型。 |

我们可以用下一小节介绍的不等于操作符`!=`来做为布尔异或操作符。

机理解释：

```go
// x    y       x && y   x || y   !x      !ytrue    true    true     true     false   falsetrue    false   false    true     false   truefalse   true    false    true     true    falsefalse   false   false    false    true    true
```

如果一个布尔运算中的一个操作值为类型确定的，则结果为一个和此操作值类型相同的类型确定值。 否则，结果为一个类型不确定布尔值。

### 比较运算符

Go支持6种比较运算符：

| 字面形式 |    名称    |                      对两个操作值的要求                      |
| :------: | :--------: | :----------------------------------------------------------: |
|    ==    |    等于    | 如果两个操作数都为类型确定的，则它们的类型必须一样，或者其中一个操作数可以隐式转换为另一个操作数的类型。 两者的类型必须都为可比较类型（将在以后的文章中介绍）。如果只有一个操作数是类型确定的，则另一个类型不确定操作数必须可以隐式转换到类型确定操作数的类型。如果两个操作数都是类型不确定的，则它们必须同时为两个类型不确定布尔值、两个类型不确定字符串值或者另个类型不确定数字值。 |
|    !=    |   不等于   |                                                              |
|    <     |    小于    | 两个操作值的类型必须相同并且它们的类型必须为整数类型、浮点数类型或者字符串类型。 |
|    <=    | 小于或等于 |                                                              |
|    >     |    大于    |                                                              |
|    >=    | 大于或等于 |                                                              |

比较运算的结果总是一个类型不确定布尔值。 如果一个比较运算中的两个操作数都为常量，则结果布尔值也为一个常量。

以后，如果我们说两个值可以比较，我们的意思是说这两个值可以用`==`或者`!=`运算符来比较。 我们将在以后的文章中，我们将了解到某些类型的值是不能比较的。

注意，并非所有的实数在内存中都可以被精确地表示，所以比较两个浮点数或者复数的结果并不是很可靠。 在编程中，我们常常比较两个浮点数的差值是否小于一个阙值来检查两个浮点数是否相等。

### 操作符运算的优先级

Go中的操作符运算的优先级和其它流行语言有一些差别。 下面列出了本文介绍的操作符的优先级。 同一行中的操作符的优先级是一样的。优先级逐行递减。

```go
*   /   %   <<  >>  &   &^+   -   |   ^==  !=  <   <=  >   >=&&||
```



一个和其它流行语言明显的差别是，移位运算`<<`和`>>`的优先级比加减法`+`和`-`的优先级要高。

一个表达式（做为一个子表达式）可以出现在另一个表达式中。 这个子表达式的估值结果将成为另一个表达式的一个操作数。 在这样的复杂表达式中，对于相同优先级的运算，它们将从左到右进行估值。 和很多其它语言一样，我们也可用一对小括号`()`来提升一个子运算的优先级。



### 更多关于常量表达式

常量子表达式的顺序有可能影响到最终的估值结果。

下面这个声明的变量将被初始化为`2.2`，而不是`2.7`。 优先级更高的子表达式`3/2`是一个常量表达式，所以它将在编译阶段被估值。 根据上面介绍的规则，在运算中，`3`和`2`都被视为`int`，所以`3/2`的估值结果为`1`。 在常量表达式`1.2 + 1`的运算中，两个操作数的类型被视为`float64`，所以最终的估值结果为`2.2`。

```go
var x = 1.2 + 3/2
```



再比如下例，在一个常量声明中，`3/2`先被估值，其结果为`1`，所以最终的估值结果为`0.1`。 在第二个常量声明中，`0.1*3`先被估值，其结果为`0.3`，所以最终的估值结果为`0.15`。

```go
package mainconst x = 3/2*0.1const y = 0.1*3/2func main() {	println(x) // +1.000000e-001	println(y) // +1.500000e-001}
```



### 更多其它操作符

Go中还有一些其它操作符。它们将在后续其它适当的文章中介绍。
