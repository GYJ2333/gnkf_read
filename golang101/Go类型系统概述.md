# Go类型系统概述

### 基本类型（basic type）

内置基本类型:

- 内置字符串类型：`string`.
- 内置布尔类型：`bool`.
- 内置数值类型：
  - `int8`、`uint8`（`byte`）、`int16`、`uint16`、`int32`（`rune`）、`uint32`、`int64`、`uint64`、`int`、`uint`、`uintptr`。
  - `float32`、`float64`。
  - `complex64`、`complex128`。

注意，**`byte`是`uint8`的一个内置别名，`rune`是`int32`的一个内置别名**。



### 组合类型（composite type）

组合类型：

- [指针类型](https://gfw.go101.org/article/pointer.html) - 类C指针

- [结构体类型](https://gfw.go101.org/article/struct.html) - 类C结构体

- [函数类型](https://gfw.go101.org/article/function.html) - 函数类型在Go中是一种一等公民类别

  一等公民类别：支持所有操作的实体， 这些操作通常包括作为参数传递，从函数返回，修改并分配给变量等。

- 容器类型

  - 数组类型 - 定长容器类型
  - 切片类型 - 动态长度和容量容器类型
  - 映射类型（map）- 也常称为字典类型。在标准编译器中映射是使用**哈希表**实现的。

- [通道类型](https://gfw.go101.org/article/channel.html) - 通道用来同步并发的协程

- [接口类型](https://gfw.go101.org/article/interface.html) - 接口在**反射和多态**中发挥着重要角色

```go
// 假设T为任意一个类型，Tkey为一个支持比较的类型。

*T         // 一个指针类型
[5]T       // 一个元素类型为T、元素个数为5的数组类型
[]T        // 一个元素类型为T的切片类型
map[Tkey]T // 一个键值类型为Tkey、元素类型为T的映射类型

// 一个结构体类型
struct {
	name string
	age  int
}

// 一个函数类型
func(int) (bool, string)

// 一个接口类型
interface {
	Method0(string) int
	Method1() (int, bool)
}

// 几个通道类型
chan T
chan<- T  //只写
<-chan T  //只读
```



### 类型的种类

每种上面提到的基本类型和组合类型都对应着一个类型种类（kind）。



你可以通过 reflect.TypeOf(var) 形式的函数调用获取变量的类型，它会返回一个类型为 reflect.Type 的变量，reflect.Type 中的操作方法Kind()返回类别。

type和kind的区别：当你定义一个名称为 Foo 的结构体，那么它的 kind 是 struct，而它的 type 是 Foo。



### 类型定义（type definition declaration）

类型定义又称类型定义声明，另一种新的类型声明形式为类型别名声明。

```go
// 自定义类型myInt，基本类型是int
type myInt int

//将 int 类型取一个别名intAlias
type intAlias = int
```

在Go中，我们可以用如下形式来定义新的类型。

```go
// 定义单个类型。
type NewTypeName SourceType

// 定义多个类型。
type (
	NewTypeName1 SourceType1
	NewTypeName2 SourceType2
)
```

新的类型名必须为标识符。但是请注意：包级类型（以及类型别名）的名称不能为[`init`](https://gfw.go101.org/article/packages-and-imports.html#init)。

注意：

- 一个新定义的类型和它的源类型为两个不同的类型。
- 在两个不同的类型定义中的定义的两个类型肯定为两个不同的类型。
- 一个新定义的类型和它的源类型的底层类型一致并且它们的值可以相互显式转换。
- 类型定义可以出现在函数体内。

一些类型定义的例子：

```go
// 下面这些新定义的类型和它们的源类型都是基本类型。
type (
	MyInt int
	Age   int
	Text  string
)

// 下面这些新定义的类型和它们的源类型都是组合类型。
type IntPtr *int
type Book struct{author, title string; pages int}
type Convert func(in0 int, in1 bool)(out0 int, out1 string)
type StringArray [5]string
type StringSlice []string

func f() {
	// 这三个新定义的类型名称只能在此函数内使用。
	type PersonAge map[string]int
	type MessageQueue chan string
	type Reader interface{Read([]byte) int}
}
```



### 类型别名声明（type alias declaration）

上面已经提到了，Go中有两个内置类型别名：`byte`（类型`uint8`的别名）和`rune`（类型`int32`的别名）。

从Go 1.9开始，我们可以使用下面的语法来声明自定义类型别名。此语法和类型定义类似，但是请注意**每个类型描述中多了一个等号`=`**。

```go
type (
	Name = string
	Age  = int
)

type table = map[string]int
type Table = map[Name]Age
```

类型别名也必须为标识符。同样地，类型别名可以被声明在函数体内。

在上面的类型别名声明的例子中，`Name`是内置类型`string`的一个别名，它们**表示同一个类型**。 

事实上，文字表示形式`map[string]int`和`map[Name]Age`也表示同一类型。 所以，`table`和`Table`一样表示同一个类型。

注意，尽管两个别名`table`和`Table`表示同一个类型，但`Table`是导出的，所以它可以被其它包引入使用，而`table`却不可以。



### 定义类型和非定义类型（defined type and undefined type）

一个定义类型是一个在某个类型定义声明中定义的类型。

所有的基本类型都是定义类型。一个非定义类型一定是一个组合类型。

在下面的例子中，别名`C`和类型字面表示`[]string`都表示同一个非定义类型。 类型`A`和别名`B`均表示同一个定义类型。

```go
type A []string
type B = A
type C = []string
```



### 概念：有名类型和无名类型（named type and unnamed type）

在Go 1.9之前，**有名类型**这一术语准确地定义在Go白皮本中。它曾被定义为一个有名字的类型。 随着Go 1.9中引入的类型别名新特性，此术语被从白皮书中删除了，原因是它可能会造成一些理解上的困惑。 比如，一些类型字面表示（比如上一节出现中的别名`C`）是一个标识符（即一个名称），但是它们所表示的类型（比如`[]string`）在Go 1.9之前却被称为无名类型。

为了避免出现这样的困惑，从Go 1.9开始，一个新的术语**定义类型**被引入来填补移除**有名类型**后的空白。 然而此举也给一些概念解释造成了[新的](https://github.com/golang/go/issues/22005)[障碍](https://github.com/golang/go/issues/32496)，或者形成了一些[尴尬的局面](https://github.com/golang/example/tree/master/gotypes#named-types)。 为了避免这些尴尬的局面和解释上的障碍，Go语言101中的文章将遵守如下原则：

- 一个类型别名将不会被称为一个类型，尽管我们常说它表示着一个类型。
- 术语**有名类型**和**定义类型**将被视为完全相同的概念。（同样地，**无名类型**和**非定义类型**亦为同一概念。） 换句话说，当提到“一个类型别名`T`是一个有名类型”，其实际意义是类型别名`T`表示着一个有名类型。 如果`T`表示着一个无名类型，则我们不应该说`T`是一个有名类型，即使别名`T`它本身拥有一个名字。
- 当我们提及一个类型名（称），它可能是一个定义类型的名称，也可能是一个类型别名的名称。



### 底层类型（underlying type）

在Go中，每个类型都有一个底层类型。规则：

- 一个内置类型的底层类型为它自己。
- `unsafe`标准库包中定义的`Pointer`类型的底层类型是它自己。（我们也可以认为`unsafe.Pointer`类型的底层类型为`*T`，其中`T`表示一个任意类型。）
- 一个非定义类型（必为一个组合类型）的底层类型为它自己。
- 在一个类型声明中，新声明的类型和源类型共享底层类型。

一个例子：

```go
// 这四个类型的底层类型均为内置类型int。
type (
	MyInt int
	Age   MyInt
)

// 下面这三个新声明的类型的底层类型各不相同。
type (
	IntSlice   []int   // 底层类型为[]int
	MyIntSlice []MyInt // 底层类型为[]MyInt
	AgeSlice   []Age   // 底层类型为[]Age
)

// 类型[]Age、Ages和AgeSlice的底层类型均为[]Age。
type Ages AgeSlice
```



如何溯源一个声明的类型的底层类型？规则很简单，在溯源过程中，当遇到一个内置类型或者非定义类型时，溯源结束。 以上面这几个声明的类型为例，下面是它们的底层类型的溯源过程：

```
MyInt → int
Age → MyInt → int
IntSlice → []int
MyIntSlice → []MyInt → []int
AgeSlice → []Age → []MyInt → []int
Ages → AgeSlice → []Age → []MyInt → []int
```



在Go中，

- 底层类型为内置类型`bool`的类型称为**布尔类型**；
- 底层类型为任一内置整数类型的类型称为**整数类型**；
- 底层类型为内置类型`float32`或者`float64`的类型称为**浮点数类型**；
- 底层类型为内置类型`complex64`或`complex128`的类型称为**复数类型**；
- 整数类型、浮点数类型和复数类型统称为**数字值类型**；
- 底层类型为内置类型`string`的类型称为**字符串类型**。



### 值（value）

一个类型的一个实例称为此类型的一个值。一个类型可以有很多不同的值，其中一个为它的零值。 同一类型的不同值共享很多相同的属性。

每个类型有一个零值。一个类型的零值可以看作是此类型的默认值。 预声明的标识符`nil`可以看作是切片、映射、函数、通道、指针（包括非类型安全指针）和接口类型的零值的字面量表示。 



### 概念：值部（value part）

在运行时刻，很多值是存储在内存的。每个这样的值都有一个直接部分，但是有一些值还可能有一个或多个间接部分。每个值部分在内存中都占据一段连续空间。 通过[安全](https://gfw.go101.org/article/pointer.html)或者[非安全](https://gfw.go101.org/article/unsafe.html)指针，一个值的间接部分被此值的直接部分所引用。



### 概念：值尺寸（value size）

一个值存储在内存中是要占据一定的空间的。此空间的大小称为此值的尺寸。值尺寸是用字节数来衡量的。 在Go中，当我们谈及一个值的尺寸，如果没有特殊说明，我们一般是指此值的直接部分的尺寸。 某个特定类别的所有类型的值的尺寸都是一样的。因为这个原因，我们也常将一个值的尺寸说成是它的类型的尺寸（或值尺寸）。

我们可以用`unsafe`标准库包中的`Sizeof`函数来取得任何一个值的尺寸。



### 概念：指针类型的基类型（base type）

如果一个指针类型的底层类型表示为`*T`，则此指针类型的基类型为`T`所表示的类型。



### 结构体类型的字段（field）

一个结构体类型由若干成员变量组成。每个这样的成员变量称为此结构体的一个字段。 比如，下面这个结构体类型含有三个字段：`author`、`title`和`pages`。

```go
struct {
	author string
	title  string
	pages  int
}
```



### 函数类型的签名（signature）

一个函数类型的签名由此函数的输入参数和返回结果的类型列表组成。 函数名称和函数体不属于函数签名的构成部分。



### 类型的方法（method）和方法集（method set）

在Go中，我们可以给满足某些条件的类型声明[方法](https://gfw.go101.org/article/method.html)。方法也常被称为成员函数。 一个类型的所有方法组成了此类型的方法集。



### 概念：接口类型的动态类型和动态值

接口类型的值称为接口值。一个接口值可以包裹装载一个非接口值。包裹在一个接口值中的非接口值称为此接口值的动态值。此动态值的类型称为此接口值的动态类型。 一个什么也没包裹的接口值为一个零值接口值。零值接口值的动态值和动态类型均为不存在。

一个接口类型可以指定若干个（可以是零个）方法，这些方法形成了此接口类型的方法集。

如果一个类型（可以是接口或者非接口类型）的方法集是一个接口类型的方法集的超集，则我们说此类型[实现](https://gfw.go101.org/article/interface.html#implementation)了此接口类型。

*如果一个集合S2中的每一个元素都在集合S1中，且集合S1中可能包含S2中没有的元素，则集合S1就是S2的一个超集。*



### 概念：一个值的具体类型（concrete type）和具体值（concrete value）

对于一个（类型确定的）非接口值，它的具体类型就是它的类型，它的具体值就是它自己。

一个零值接口值没有具体类型和具体值。 对于一个非零值接口值，它的具体类型和具体值就是它的动态类型和动态值。



### 容器类型

数组、切片和映射是Go中的三种正式意义上的内置容器类型。

有时候，字符串和通道类型也可以被非正式地看作是容器类型。

（正式和非正式的）容器类型的每个值都有一个长度属性。



### 概念：映射类型的键值（key）类型

如果一个映射类型的底层类型表示为`map[Tkey]T`，则此映射类型的键值类型为`Tkey`。 `Tkey`必须为一个可比较类型。

### 概念：容器类型的元素（element）类型

存储在一个容器值中的所有元素的类型必须为同一个类型。此同一类型称为此容器值的（容器）类型的元素类型。

- 如果一个数组类型的底层类型表示为`[N]T`，则此数组类型的元素类型为`T`所表示的类型。
- 如果一个切片类型的底层类型表示为`[]T`，则此切片类型的元素类型为`T`所表示的类型。
- 如果一个映射类型的底层类型表示为`map[Tkey]T`，则此映射类型的元素类型为`T`所表示的类型。
- 如果一个通道类型的底层类型表示为`chan T`、`chan<- T`或者`<-chan T`，则此通道类型的元素类型为`T`所表示的类型。
- 一个字符串类型的元素类型总是内置类型`byte`（亦即`uint8`）。

### 概念：通道类型的方向

一个通道值可以被看作是先入先出（first-in-first-out，FIFO）队列。一个通道值可能是可读可写的、只读的（receive-only）或者只写的（send-only）。

- 一个可读可写的通道值也称为一个双向通道。 一个双向通道类型的底层类型可以被表示为`chan T`。
- 我们只能向一个只写的通道值发送数据，而不能从其中接收数据。 只写通道类型的底层类型可以被表示为`chan<- T`。
- 我们只能从一个只读的通道值接收数据，而不能向其发送数据。 只读通道类型的底层类型可以被表示为`<-chan T`。



### 事实：可比较类型和不可比较类型

目前（Go 1.16），下面这些类型的值不支持（使用`==`和`!=`运算标识符）比较。这些类型称为不可比较类型。

- 切片类型
- 映射类型
- 函数类型
- 任何包含有不可比较类型的字段的结构体类型和任何元素类型为不可比较类型的数组类型。

其它类型称为可比较类型。

映射类型的键值类型必须为可比较类型。



