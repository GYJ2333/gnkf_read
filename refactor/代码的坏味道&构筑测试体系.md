# 第三章 代码的坏味道



## 命名问题

整洁代码最重要的一环就是好的名字，所以我们会深思熟虑如何给函数、模块、变量和类命名，使它们能清晰地表明自己的功能和用法。但好的命名是编程中最难的两件事之一，很难一下子就把名字取好，所以需要在编程过程中对一些命名不断修改。 改名不仅仅是修改名字而已。如果你想不出一个好名字，说明背后很可能潜藏着更深的设计问题。为一个恼人的名字所付出的纠结，常常能推动我们对代码进行精简。



## 重复代码

如果在多个地方看到看到相同的代码结构，那么将其合而为一肯定是更好的。因为要修改这些重复的代码必须将其所有的副本都进行修改。

如果重复代码只是相似，那么可以重组代码顺序，把相同的放在一起。



## 过长函数

函数越长，就难理解。可能很多人认为小函数会给代码阅读者带来负担，因为需要经常的切换上下文，但是现代IDE可以让我们在函数间很方便的跳转，因此可以很好的解决这个问题。

我们应遵循这样一个原则：每当感觉需要以注释来说明点什么的时候，我们就把需要说明的东西放进一个独立的函数，并以其用途命名。哪怕替换后的函数调用动作比函数自身还长，只要函数名称能够解释其用途，我们也该毫不犹豫地那么做。关键不在于函数的长度，而在于函数“做什么”和“如何做”之间的语义距离。

就算只有一行代码，如果它需要以注释来说明，那也值得将它提炼到独立的函数中去。



## 过长参数列表

过长的参数列表增加了函数的复杂性，容易令人迷惑。

如果一个参数可以通过另一个参数计算得到，那么就可以取消这个参数；如果传过去的参数是通过现有的数据结构抽取出来的，那么就可以传入完整的该数据结构；如果几个参数总是同时出现在函数的参数中，那么可以将其合成一个自定义对象传入需要的函数。



## 全局数据

全局数据的问题在于，从代码库的任何一个角落都可以修改它，而且没有任何机制可以探测出到底哪段代码做出了修改。 并且全局数据造成的bug很难定位。

首要的防御手段是封装变量，比如用一个函数将其包装起来，这样就能看到修改它的地方以及控制对它的访问，然后最好还将其搬移到一个类或者模块中去，只允许模块内的代码使用它，从而尽量控制其作用域。



## 可变数据

如果一个数据可以通过多处地方进行修改，那么很容易造成bug。

如果一个变量在不同时候被用于存储不同的东西，可以使用拆分变量将其拆分为各自不同用途的变量，从而避免危险的更新操作。

设计
API时，可以使用将查询函数和修改函数分离确保调用者不会调到有副作用的代码，除非他们真的需要更新数据。



## 发散式变化

如果需要修改，应尽量让修改集中在一点，然后只在该处修改就好了。处理的方法通常是使用提炼函数将原本需要在多处修改的地方尽可能的集中到一处。



## 散弹式修改

如果每遇到某种变化，你都必须在许多不同的类内做出许多小修改，这就是霰弹式修改。这样不但很难找到修改点，也很容易错过某个重要的修改。

这种情况下，你应该使用搬移函数和搬移字段 把所有需要修改的代码放进同一个模块里。如果有很多函数都在操作相似的数据，可以使用函数组合成类。

> 发散式变化和散弹式修改的区别：发散式变化强调的是因为要改一个东西，导致需要在多处进行同样的修改。散弹式修改强调的是因为要改一个东西，导致要在多处进行小的修改。注意：发散式是修改同样的东西；散弹式是在多处进行小的不同的修改（有点蝴蝶效应的意思）。

## 依恋情结

如果一个函数跟另一个模块中的函数或者数据交流格外频繁，远胜于在自己所处模块内部的交流，这就是依恋情结的典型情况。

如果某个函数想跟这些数据待在一起，那就使用搬移函数把它移过去。有时候，函数中只有一部分受这种依恋之苦，这时候应该使用提炼函数把这一部分提炼到独立的函数中，再使用搬移函数将其搬移过去。



## 数据泥团

当经常看到两个以上的类中相同的字段、许多函数签名中相同的参数时，可以创建一个独立的数据结构，将这些重复出现的字段或参数提炼到一起。这样做的好处是可以将很多函数参数列表缩短，简化函数的调用。

不必在意新提炼出的数据结构在被使用时其中的数据没有被完全使用，只要这个新对象取代了之前两个以上的字段或参数就是值得的。



## 基本类型偏执

当使用基本类型不是能很好的表达我们想要的内容时，用自定义的对象来取代它。



## 循环语句

如今，函数作为一等公民已经得到了广泛的支持，因此我们可以使用以管道取代循环。我们发现，管道操作（如filter和map）可以帮助我们更快地看清被处理的元素以及处理它们的动作。



## 冗赘的元素

去除多余的类和函数等程序元素。比如一个类就是一个简单的函数，一个函数名和其实现代码一样，并且很少被调用。



## 想当然的通用性

当我们觉得总有一天要做这件事，然后用各式各样的钩子和特殊情况来处理一些非必要的事情时，糟糕的设计可能就出现了。如果能确保所设计的都会被用到，那值得这么做，如果用不到，就不值得。



## 临时字段

不要在类中设计一些只为某种特定情况而需要的字段，这样的代码不容易让人看懂。可以创建一个提炼类，然后用搬移函数将所有和这个字段相关的代码放进这个类中。



## 过长的消息链

不要为了得到一个值而采用一长串的函数调用。重构方法通常是先观察调用链最终返回的结果是干什么的，然后看看是否以提炼函数把使用该结果的代码提炼到一个独立的函数中，再运用搬移函数把这个函数加入调用链，这样为了得到结果只需要调用一个函数就可以了。



## 中间人

不要设计出 ”将某个类的一半以上的函数都委托给其他类“ 这种代码，这时应该移除中间人，直接和真正负责的对象打交道。



## 过大的类

如果想利用单个类做太多事情，其内往往就会出现太多字段。一旦如此，重复代码也就接踵而至了。重构的方法就是对其进行拆分，看看使用者是否只用到了这个类所有功能的一个子集，每个这样的子集都可能拆分成一个独立的类。 



## 纯数据类

所谓纯数据类是指：它们拥有一些字段， 以及用于访问（读写） 这些字段的函数， 除此之外一无长物。只要把处理数据的行为搬移到纯数据类里来，就能使情况大为改观。 



## 被拒绝的遗赠

子类应该继承超类的函数和数据。但如果它们不想或不需要继承，又该怎么办呢？   这就意味着继承体系设计错误。你需要为这个子类新建一个兄弟类，再运用函数下移和字段下移把所有用不到的函数下推给那个兄弟。 



## 注释

如果你需要注释来解释一块代码做了什么，试试提炼函数；如果函数已经提炼出来，但还是需要注释来解释其行为，试试用改变函数声明为它改名；如果你需要注释说明某些系统的需求规格，试试引入断言。

如果你不知道该做什么，这才是注释的良好运用时机。除了用来记述将来的打算之外，注释还可以用来标记你并无十足把握的区域。你可以在注释里写下自己“为什么做某某事”。这类信息可以帮助将来的修改者，尤其是那些健忘的家伙。





# 第四章 构筑测试体系

测试不仅可以帮助进行正确的重构，还有利于编写优良的程序，提升编码速度。

## 自测试代码的价值

总的来说，如果不想被bug折腾的噩梦缠身，就走上自测试代码这条路吧。一个较好的写测试的时机是在编写代码之前，因为编写测试能让我们将注意力集中在接口而不是实现上。这种方式被发展成了一门技艺——“测试驱动开发”，其一般工作流程是先写一个测试，然后编写代码让测试通过，接着再重构代码，最后不断循环这三个步骤。

## 探测边界性条件

通常我们在测试时习惯测试“正常路径”，也就是一切正常，用户使用方式也符合规范的场景。但把测试扩展到一些边界处也是需要的，这可以检查操作出错时软件的表现。比如输入一个大于int能表示的数据范围的数值等等这种特殊情况。